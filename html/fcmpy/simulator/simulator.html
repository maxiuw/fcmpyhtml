<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fcmpy.simulator.simulator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fcmpy.simulator.simulator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np
import warnings
from typing import Union
from abc import ABC, abstractmethod
from fcmpy.store.methodsStore import InferenceStore
from fcmpy.store.methodsStore import TransferStore
from fcmpy.store.methodsStore import ConvergenceStore
from fcmpy.expert_fcm.input_validator import type_check


class Simulator(ABC):
    &#34;&#34;&#34;
        Class of methods for simulating FCMs.
    &#34;&#34;&#34;
    @abstractmethod
    def simulate():
        raise NotImplementedError(&#39;Simulate method is not defined!&#39;)


class FcmSimulator(Simulator):
    &#34;&#34;&#34;
        The class includes methods for running simulations on top of a defined FCM.

        Methods:
            simulate(initial_state: dict, weight_matrix: Union[pd.DataFrame, np.ndarray], 
                            transfer: str, inference: str, thresh:float=0.001, iterations:int=50, 
                            output_concepts = None, convergence = &#39;absDiff&#39;, **kwargs)
    &#34;&#34;&#34;
    @staticmethod
    @type_check
    def __getStableConcepts(weight_matrix: Union[np.ndarray, pd.DataFrame]) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Extract the positions of the stable concepts (concepts with in-degree == 0).

            Parameters
            ----------
            weight_matrix: numpy.ndarray
                            N*N weight matrix of the FCM.
            
            Return
            ----------
            y: numpy.ndarray
                    the positions of the stable concepts (concepts with in-degree == 0)
        &#34;&#34;&#34;
        stables = []
        for i in range(len(weight_matrix)):
            if np.all(weight_matrix[i] == 0):
                stables.append(i)

        return stables
    
    @staticmethod
    @type_check
    def __simInputTransform(weight_matrix: Union[pd.DataFrame, np.ndarray], initial_state: dict) -&gt; tuple:
        &#34;&#34;&#34;
            Transform the weight matrix and initial state vector for the simulation.
        &#34;&#34;&#34;
        if type(weight_matrix) != np.ndarray:
            # Align the initial_vector order for correct computations (vec . mat)
            initial_state = {k : initial_state[k] for k in weight_matrix.columns}
            weight_matrix=weight_matrix.to_numpy()
        else:
            warnings.warn(&#34;When passing an initial state with a weight matrix type \
                numpy.ndarray make sure that the order of the keys in the dictionary \
                with the initial states matches the order of the column of the numpy.ndarray!&#34;)
        
        return weight_matrix, initial_state

    @staticmethod
    @type_check
    def __outputConceptCheck(output_concepts: Union[None, list], initial_state: dict):
        &#34;&#34;&#34;
            Check if output concepts are in the initial_state.keys()
        &#34;&#34;&#34;
        if output_concepts:
            r = set(output_concepts) - set(initial_state.keys())
            if r:
                raise ValueError(f&#39;The specified output concept {r} is not in the list.&#39;)
    
    @staticmethod
    @type_check
    def simulate(initial_state: dict, weight_matrix: Union[pd.DataFrame, np.ndarray], 
                        transfer: str, inference: str, thresh:float=0.001, iterations:int=50, 
                        output_concepts = None, convergence = &#39;absDiff&#39;, **kwargs) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
            Runs simulations over the passed FCM.
            
            Parameters
            ----------
            initial_state: dict
                            initial state vector of the concepts
                            keys ---&gt; concepts, values ---&gt; initial state of the associated concept

            weight_matrix: pd.DataFrame, np.ndarray
                            N*N weight matrix of the FCM.

            transfer: str
                        transfer function --&gt; &#34;sigmoid&#34;, &#34;bivalent&#34;, &#34;trivalent&#34;, &#34;tanh&#34;

            inference: str
                        inference method --&gt; &#34;kosko&#34;, &#34;mKosko&#34;, &#34;rescaled&#34;

            thresh: float
                        threshold for the error

            iterations: int
                            number of iterations

            output_concepts: bool, list
                                the output concepts for the convergence check
                                default --&gt; None

            convergence: str,
                            convergence method
                            default --&gt; &#39;absDiff&#39;: absolute difference between the simulation steps

            kwargs: additional parameters for the methods (e.g., lambda (l) parameter for the sigmoid function)

            Return
            ----------
            y: pandas.DataFrame
                    results of the simulation.
        &#34;&#34;&#34;
        # Check the output concepts.
        FcmSimulator.__outputConceptCheck(output_concepts=output_concepts,
                                        initial_state=initial_state)

        # Transform the inputs if necessary.
        weight_matrix, initial_state = FcmSimulator.__simInputTransform(weight_matrix=weight_matrix,
                                                                        initial_state=initial_state)

        # create the empty dataframe for the results
        results = pd.DataFrame(initial_state, index=[0])
        state_vector = np.array(list(initial_state.values()))

        # get the stable concept values
        stableConceptPos = FcmSimulator.__getStableConcepts(weight_matrix=weight_matrix.T)
        satble_values = state_vector[stableConceptPos]

        # get the methods for the simulation.
        transfer = TransferStore.get(transfer)()
        inference = InferenceStore.get(inference)()
        conv = ConvergenceStore.get(convergence)()
        
        # initialize params
        convergenceStatus = False
        step_count = 0

        for _ in range(iterations):
            if not convergenceStatus:    
                infered = inference.infer(initial_state=state_vector, weight_matrix=weight_matrix, params=kwargs) # Inference
                state_vector = transfer.transfer(x=infered, params=kwargs) # Apply transfer func on the results
                
                # Reset the stable values
                state_vector[stableConceptPos] = satble_values

                # Append the results
                results.loc[len(results)] = state_vector

                # update the step_count
                step_count +=1
                
                # compute the residuals between the steps.
                convergenceStatus = conv.check_convergence(output_concepts=output_concepts, results=results, threshold = thresh, params=kwargs) 
            else:    
                print(f&#39;The values converged in the {step_count+1} state (e &lt;= {thresh})&#39;)
                break

            if step_count &gt;= iterations:
                warnings.warn(&#34;The values didn&#39;t converge. More iterations are required!&#34;)

        return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fcmpy.simulator.simulator.FcmSimulator"><code class="flex name class">
<span>class <span class="ident">FcmSimulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>The class includes methods for running simulations on top of a defined FCM.</p>
<h2 id="methods">Methods</h2>
<p>simulate(initial_state: dict, weight_matrix: Union[pd.DataFrame, np.ndarray],
transfer: str, inference: str, thresh:float=0.001, iterations:int=50,
output_concepts = None, convergence = 'absDiff', **kwargs)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FcmSimulator(Simulator):
    &#34;&#34;&#34;
        The class includes methods for running simulations on top of a defined FCM.

        Methods:
            simulate(initial_state: dict, weight_matrix: Union[pd.DataFrame, np.ndarray], 
                            transfer: str, inference: str, thresh:float=0.001, iterations:int=50, 
                            output_concepts = None, convergence = &#39;absDiff&#39;, **kwargs)
    &#34;&#34;&#34;
    @staticmethod
    @type_check
    def __getStableConcepts(weight_matrix: Union[np.ndarray, pd.DataFrame]) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Extract the positions of the stable concepts (concepts with in-degree == 0).

            Parameters
            ----------
            weight_matrix: numpy.ndarray
                            N*N weight matrix of the FCM.
            
            Return
            ----------
            y: numpy.ndarray
                    the positions of the stable concepts (concepts with in-degree == 0)
        &#34;&#34;&#34;
        stables = []
        for i in range(len(weight_matrix)):
            if np.all(weight_matrix[i] == 0):
                stables.append(i)

        return stables
    
    @staticmethod
    @type_check
    def __simInputTransform(weight_matrix: Union[pd.DataFrame, np.ndarray], initial_state: dict) -&gt; tuple:
        &#34;&#34;&#34;
            Transform the weight matrix and initial state vector for the simulation.
        &#34;&#34;&#34;
        if type(weight_matrix) != np.ndarray:
            # Align the initial_vector order for correct computations (vec . mat)
            initial_state = {k : initial_state[k] for k in weight_matrix.columns}
            weight_matrix=weight_matrix.to_numpy()
        else:
            warnings.warn(&#34;When passing an initial state with a weight matrix type \
                numpy.ndarray make sure that the order of the keys in the dictionary \
                with the initial states matches the order of the column of the numpy.ndarray!&#34;)
        
        return weight_matrix, initial_state

    @staticmethod
    @type_check
    def __outputConceptCheck(output_concepts: Union[None, list], initial_state: dict):
        &#34;&#34;&#34;
            Check if output concepts are in the initial_state.keys()
        &#34;&#34;&#34;
        if output_concepts:
            r = set(output_concepts) - set(initial_state.keys())
            if r:
                raise ValueError(f&#39;The specified output concept {r} is not in the list.&#39;)
    
    @staticmethod
    @type_check
    def simulate(initial_state: dict, weight_matrix: Union[pd.DataFrame, np.ndarray], 
                        transfer: str, inference: str, thresh:float=0.001, iterations:int=50, 
                        output_concepts = None, convergence = &#39;absDiff&#39;, **kwargs) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
            Runs simulations over the passed FCM.
            
            Parameters
            ----------
            initial_state: dict
                            initial state vector of the concepts
                            keys ---&gt; concepts, values ---&gt; initial state of the associated concept

            weight_matrix: pd.DataFrame, np.ndarray
                            N*N weight matrix of the FCM.

            transfer: str
                        transfer function --&gt; &#34;sigmoid&#34;, &#34;bivalent&#34;, &#34;trivalent&#34;, &#34;tanh&#34;

            inference: str
                        inference method --&gt; &#34;kosko&#34;, &#34;mKosko&#34;, &#34;rescaled&#34;

            thresh: float
                        threshold for the error

            iterations: int
                            number of iterations

            output_concepts: bool, list
                                the output concepts for the convergence check
                                default --&gt; None

            convergence: str,
                            convergence method
                            default --&gt; &#39;absDiff&#39;: absolute difference between the simulation steps

            kwargs: additional parameters for the methods (e.g., lambda (l) parameter for the sigmoid function)

            Return
            ----------
            y: pandas.DataFrame
                    results of the simulation.
        &#34;&#34;&#34;
        # Check the output concepts.
        FcmSimulator.__outputConceptCheck(output_concepts=output_concepts,
                                        initial_state=initial_state)

        # Transform the inputs if necessary.
        weight_matrix, initial_state = FcmSimulator.__simInputTransform(weight_matrix=weight_matrix,
                                                                        initial_state=initial_state)

        # create the empty dataframe for the results
        results = pd.DataFrame(initial_state, index=[0])
        state_vector = np.array(list(initial_state.values()))

        # get the stable concept values
        stableConceptPos = FcmSimulator.__getStableConcepts(weight_matrix=weight_matrix.T)
        satble_values = state_vector[stableConceptPos]

        # get the methods for the simulation.
        transfer = TransferStore.get(transfer)()
        inference = InferenceStore.get(inference)()
        conv = ConvergenceStore.get(convergence)()
        
        # initialize params
        convergenceStatus = False
        step_count = 0

        for _ in range(iterations):
            if not convergenceStatus:    
                infered = inference.infer(initial_state=state_vector, weight_matrix=weight_matrix, params=kwargs) # Inference
                state_vector = transfer.transfer(x=infered, params=kwargs) # Apply transfer func on the results
                
                # Reset the stable values
                state_vector[stableConceptPos] = satble_values

                # Append the results
                results.loc[len(results)] = state_vector

                # update the step_count
                step_count +=1
                
                # compute the residuals between the steps.
                convergenceStatus = conv.check_convergence(output_concepts=output_concepts, results=results, threshold = thresh, params=kwargs) 
            else:    
                print(f&#39;The values converged in the {step_count+1} state (e &lt;= {thresh})&#39;)
                break

            if step_count &gt;= iterations:
                warnings.warn(&#34;The values didn&#39;t converge. More iterations are required!&#34;)

        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fcmpy.simulator.simulator.Simulator" href="#fcmpy.simulator.simulator.Simulator">Simulator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fcmpy.simulator.simulator.FcmSimulator.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>initial_state: dict, weight_matrix: Union[pandas.core.frame.DataFrame, numpy.ndarray], transfer: str, inference: str, thresh: float = 0.001, iterations: int = 50, output_concepts=None, convergence='absDiff', **kwargs) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Runs simulations over the passed FCM.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>dict</code></dt>
<dd>initial state vector of the concepts
keys &mdash;&gt; concepts, values &mdash;&gt; initial state of the associated concept</dd>
<dt><strong><code>weight_matrix</code></strong> :&ensp;<code>pd.DataFrame, np.ndarray</code></dt>
<dd>N*N weight matrix of the FCM.</dd>
<dt><strong><code>transfer</code></strong> :&ensp;<code>str</code></dt>
<dd>transfer function &ndash;&gt; "sigmoid", "bivalent", "trivalent", "tanh"</dd>
<dt><strong><code>inference</code></strong> :&ensp;<code>str</code></dt>
<dd>inference method &ndash;&gt; "kosko", "mKosko", "rescaled"</dd>
<dt><strong><code>thresh</code></strong> :&ensp;<code>float</code></dt>
<dd>threshold for the error</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>number of iterations</dd>
<dt><strong><code>output_concepts</code></strong> :&ensp;<code>bool, list</code></dt>
<dd>the output concepts for the convergence check
default &ndash;&gt; None</dd>
<dt><strong><code>convergence</code></strong> :&ensp;<code>str,</code></dt>
<dd>convergence method
default &ndash;&gt; 'absDiff': absolute difference between the simulation steps</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>additional parameters for the methods (e.g., lambda (l) parameter for the sigmoid function)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="return">Return</h2>
<p>y: pandas.DataFrame
results of the simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@type_check
def simulate(initial_state: dict, weight_matrix: Union[pd.DataFrame, np.ndarray], 
                    transfer: str, inference: str, thresh:float=0.001, iterations:int=50, 
                    output_concepts = None, convergence = &#39;absDiff&#39;, **kwargs) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
        Runs simulations over the passed FCM.
        
        Parameters
        ----------
        initial_state: dict
                        initial state vector of the concepts
                        keys ---&gt; concepts, values ---&gt; initial state of the associated concept

        weight_matrix: pd.DataFrame, np.ndarray
                        N*N weight matrix of the FCM.

        transfer: str
                    transfer function --&gt; &#34;sigmoid&#34;, &#34;bivalent&#34;, &#34;trivalent&#34;, &#34;tanh&#34;

        inference: str
                    inference method --&gt; &#34;kosko&#34;, &#34;mKosko&#34;, &#34;rescaled&#34;

        thresh: float
                    threshold for the error

        iterations: int
                        number of iterations

        output_concepts: bool, list
                            the output concepts for the convergence check
                            default --&gt; None

        convergence: str,
                        convergence method
                        default --&gt; &#39;absDiff&#39;: absolute difference between the simulation steps

        kwargs: additional parameters for the methods (e.g., lambda (l) parameter for the sigmoid function)

        Return
        ----------
        y: pandas.DataFrame
                results of the simulation.
    &#34;&#34;&#34;
    # Check the output concepts.
    FcmSimulator.__outputConceptCheck(output_concepts=output_concepts,
                                    initial_state=initial_state)

    # Transform the inputs if necessary.
    weight_matrix, initial_state = FcmSimulator.__simInputTransform(weight_matrix=weight_matrix,
                                                                    initial_state=initial_state)

    # create the empty dataframe for the results
    results = pd.DataFrame(initial_state, index=[0])
    state_vector = np.array(list(initial_state.values()))

    # get the stable concept values
    stableConceptPos = FcmSimulator.__getStableConcepts(weight_matrix=weight_matrix.T)
    satble_values = state_vector[stableConceptPos]

    # get the methods for the simulation.
    transfer = TransferStore.get(transfer)()
    inference = InferenceStore.get(inference)()
    conv = ConvergenceStore.get(convergence)()
    
    # initialize params
    convergenceStatus = False
    step_count = 0

    for _ in range(iterations):
        if not convergenceStatus:    
            infered = inference.infer(initial_state=state_vector, weight_matrix=weight_matrix, params=kwargs) # Inference
            state_vector = transfer.transfer(x=infered, params=kwargs) # Apply transfer func on the results
            
            # Reset the stable values
            state_vector[stableConceptPos] = satble_values

            # Append the results
            results.loc[len(results)] = state_vector

            # update the step_count
            step_count +=1
            
            # compute the residuals between the steps.
            convergenceStatus = conv.check_convergence(output_concepts=output_concepts, results=results, threshold = thresh, params=kwargs) 
        else:    
            print(f&#39;The values converged in the {step_count+1} state (e &lt;= {thresh})&#39;)
            break

        if step_count &gt;= iterations:
            warnings.warn(&#34;The values didn&#39;t converge. More iterations are required!&#34;)

    return results</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fcmpy.simulator.simulator.Simulator"><code class="flex name class">
<span>class <span class="ident">Simulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class of methods for simulating FCMs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulator(ABC):
    &#34;&#34;&#34;
        Class of methods for simulating FCMs.
    &#34;&#34;&#34;
    @abstractmethod
    def simulate():
        raise NotImplementedError(&#39;Simulate method is not defined!&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fcmpy.simulator.simulator.FcmSimulator" href="#fcmpy.simulator.simulator.FcmSimulator">FcmSimulator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fcmpy.simulator.simulator.Simulator.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def simulate():
    raise NotImplementedError(&#39;Simulate method is not defined!&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fcmpy.simulator" href="index.html">fcmpy.simulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fcmpy.simulator.simulator.FcmSimulator" href="#fcmpy.simulator.simulator.FcmSimulator">FcmSimulator</a></code></h4>
<ul class="">
<li><code><a title="fcmpy.simulator.simulator.FcmSimulator.simulate" href="#fcmpy.simulator.simulator.FcmSimulator.simulate">simulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fcmpy.simulator.simulator.Simulator" href="#fcmpy.simulator.simulator.Simulator">Simulator</a></code></h4>
<ul class="">
<li><code><a title="fcmpy.simulator.simulator.Simulator.simulate" href="#fcmpy.simulator.simulator.Simulator.simulate">simulate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>